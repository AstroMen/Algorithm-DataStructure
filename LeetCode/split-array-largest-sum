// Source : https://leetcode.com/problems/split-array-largest-sum/
// Time:  O()
// Space: O()

/********************************************************************************** 
* 
* Given an array which consists of non-negative integers and an integer m, you can split the array into m non-empty continuous subarrays. Write an algorithm to minimize the largest sum among these m subarrays.
* 
* Note:
* If n is the length of array, assume the following constraints are satisfied:
*     1 ≤ n ≤ 1000
*     1 ≤ m ≤ min(50, n)
* 
* Examples:
* Input:
* nums = [7,2,5,10,8]
* m = 2
* Output:
* 18
* 
* Explanation:
* There are four ways to split nums into two subarrays.
* The best way is to split it into [7,2,5] and [10,8],
* where the largest sum among the two subarrays is only 18.
*    
**********************************************************************************/

//3ms From: https://discuss.leetcode.com/topic/61314/binary-search-c-solution/2
class Solution {
public:
    bool canSplit(vector<int>& nums, int m, long long sum) {
        int c = 1;
        long long s = 0;
        for (auto& num : nums) {
            s += num;
            if (s > sum) {
                s = num;
                ++c;
            }
        }
        return c <= m;
    }

    int splitArray(vector<int>& nums, int m) {
        long long left = 0, right = 0;
        for (auto& num : nums) {
            left = max(left, (long long)num);
            right += num;
        }
        while (left <= right) {
            long long mid = left + (right-left)/2;
            if (canSplit(nums, m, mid))  //找到了
                right = mid-1;
            else
                left = mid+1;
        }
        return left;
    }
};
